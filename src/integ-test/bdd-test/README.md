| TAG          | STEP                                                                                      | DESCRIZIONE                                                                                                                                                                                                                    |
|--------------|-------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    verify       |   **Given** systems up |     controlla se i sistemi sono running                                                                                                                                                                                            |
|    verify       |   **Given** EC {version:OldNew} version |    -|
|    soap, config |   **Step** initial XML {primitive} |     <br/> " xml "  salva nel contesto l'xml da usare per la soap {action}                                                                                                                                                                         |
|    rest, config |   **Given** initial JSON {primitive} |     <br/> " json "  salva nel contesto la chiamata rest al {service} (es: api/service?param=value)                                                                                                                                   |
|    soap, config |   **Step** RPT generation |    genera RPT valorizzata con i tag customizzati in fase di dichiarazione. Il risultato è un file codificato a base64 che si recupera dal context con chiave 'rptAttachment'|
|    soap, config |   **Given** generate {number:d} notice number and iuv with aux digit {aux_digit:d}, segregation code {segregation_code} and application code {application_code} |    genera iuv e notice_number valorizzati con i tag customizzati in fase di dichiarazione ({number},{aux digit},{segregation code},{application code}). Per generare diversi iuv e notice_number, deve essere dichiarato di nuovo questo step, con un {number} diverso.|
|    soap, config |   **Given** generate {number:d} cart with PA {pa} and notice number {notice_number} |    genera idCarrello valorizzato con i tag customizzati in fase di dichiarazione ({number},{PA},{notice number}).  Per generare diversi idCarrello, deve essere dichiarato di nuovo questo step, con un {number} diverso.|
|   config |   **Given** RPT{number:d} generation |    genera RPT{number} valorizzata con i tag customizzati in fase di dichiarazione. Il risultato è un file codificato a base64 che si recupera dal context con chiave 'rpt{number}Attachment'. Per generare diversi RPT, deve essere dichiarato di nuovo step, con un {number} diverso.|
|   config |   **Given** MB generation |    genera MB valorizzata con i tag customizzati in fase di dichiarazione. Il risultato è un file codificato a base64 che si recupera dal context con chiave 'bollo'.|
|   config |   **Given** MB{number:d} generation |    genera MB{number} valorizzata con i tag customizzati in fase di dichiarazione. Il risultato è un file codificato a base64 che si recupera dal context con chiave '{number}bollo'. Per generare diversi MB, deve essere dichiarato di nuovo step, con un {number} diverso.|
|   config |   **Given** RT{number:d} generation |    genera la RT{number} valorizzata con i tag customizzati in fase di dichiarazione.  Il risultato è un file codificato a base64 che si recupera dal context con chiave 'rt{number}Attachment'. Per generare diversi RT, deve essere dichiarato di nuovo step, con un {number} diverso.|
|   config |   **Given** RT generation |    genera la RT valorizzata con i tag customizzati in fase di dichiarazione.  Il risultato è un file codificato a base64 che si recupera dal context con chiave 'rtAttachment'.|
|   config |   **Given** RR generation |    genera la RR valorizzata con i tag customizzati in fase di dichiarazione.  Il risultato è un file codificato a base64 che si recupera dal context con chiave 'rrAttachment'.|
|   config |   **Given** ER generation |    genera la ER valorizzata con i tag customizzati in fase di dichiarazione.  Il risultato è un file codificato a base64 che si recupera dal context con chiave 'erAttachment'.|
|   config |   **Given** REND generation |    genera la REND valorizzata con i tag customizzati in fase di dichiarazione.  Il risultato è un file codificato a base64 che si recupera dal context con chiave 'rendAttachment'.|
|    soap, config |   **Given** {elem} with {value} in {action} |    modifica il {tag} del xml salvato nel contesto per la soap {action} con il valore {value}                                                                                                                                      |
|   config |   **Given** replace {old_tag} tag in {action} with {new_tag} |    sostituisce {old_tag} del xml salvato nel context per la soap {action} con il valore {new_tag}                                                                                                                                      |
|    soap, config |   **Given** {attribute} set {value} for {elem} in {primitive} |    modifica l'{attribute} del {tag} del xml salvato nel contesto per la soap {action} con il valore {value}                                                                                                                       |
|   soap, send|   **Step** {sender} sends soap {soap_primitive} to {receiver} |    effettua una chiamata soap di tipo {action} con l'xml configurato nel contesto                                                                                                                                                 |
|   soap, send|   **Step** send, by sender {sender}, soap action {soap_primitive} to {receiver} |    effettua una chiamata soap di tipo {action} con l'xml configurato nel contesto                                                                                                                                                 |
|   config|   **When** job {job_name} triggered after {seconds} seconds |    legge la risposta di un {job_name} , su un determinato nodo, triggerato dopo {seconds} secondi|
|   soap, verify|   **Then** check {tag} is {value} of {primitive} response |    verifica che il {tag} nella risposta della soap {action} abbia il valore {value}                                                                                                                                               |
|   verify|   **Then** check substring {value} in {tag} content of {primitive} response |    verifica che il valore {value}  sia una sottostringa del contenuto del {tag}|
|   verify|   **Step** checks {tag} contains {value} of {primitive} response |    verifica che la risposta della primitiva {primitive} contenga il tag {value}|
|   verify|   **Then** check {tag} contains {value} of {primitive} response |    verifica che la risposta della primitiva {primitive} contenga il tag {value}|
|   verify|   **Then** check {tag} containsList {value} of {primitive} response |   N.A.|
|   verify|   **Then** check {tag} field exists in {primitive} response |    verifica che la risposta della primitiva{primitive} contenga il campo {tag}|
|   verify|   **Then** check {tag} field not exists in {primitive} response |    verifica che la risposta della primitiva{primitive} non contenga il campo {tag}|
|   soap, verify|   **Then** {tag} length is less than {value} of {primitive} response |    verifica che il valore del {tag} nella risposta della soap {action} abbia una lunghezza minore di {value}                                                                                                                      |
|   soap, verify|   **Then** {tag} exists of {primitive} response |    verifica che il {tag} sia presente nella risposta della soap {action}                                                                                                                                                          |
|   rest, send|   **Then** check {mock:EcPsp} receives {primitive} properly |     <br/> " <noticeNumber> "  verifica che il {mock} abbia ricevuto la richiesta {primitive}. Passare il valore del noticeNumber di riferimento                                                                                                              |
|   mock, verify|   **Then** check {mock:EcPsp} receives {primitive} {status:ProperlyNotProperly} with noticeNumber {notice_number} |    verifica che il {mock} abbia ricevuto la richiesta {primitive} con status {status:ProperlyNotProperly} e con il noticeNumber {notice_number}|
|   mock, verify|   **Then** check {mock:EcPsp} receives {primitive} properly having in the receipt {value} as {elem} |    verifica che il {mock} abbia ricevuto la richiesta {primitive} correttamente avente nella ricevuta {value} per il campo {elem}                                                                                                   |
|   mock, verify|   **Then** check {mock:EcPsp} receives {primitive} properly having in the transfer with idTransfer {idTransfer} the same {elem} of {other_primitive} |    verifica che il {mock} abbia ricevuto la richiesta {primitive} correttamente, avente nel transfer con id {idtransfer} lo stesso {elem} di {other_primitive}|
|   util|   **Step** the {name} scenario executed successfully |    esegue lo scenario identificato dal nome univoco {name}                                                                                                                                                                        |
|   util|   **Step** start from {name} scenario {n:d} times |    inizia dallo scenario {name} {n:d} volte|
|   rest, send|   **When** {sender} sends rest {method:Method} {service} to {receiver} |    <br/> " json OPZIONALE "   effettua una chiamata rest al {servizio} verso il {receiver} con il body e  i parametri configurati nel contesto                                                                                                               |
|   soap, verify|   **Then** verify the HTTP status code of {action} response is {value} |    verifica lo status code della chiamata rest {service}                                                                                                                                                                          |
|    mock|   **Given** {mock} replies to {destination} with the {primitive} |     <br/>" xml OPZIONALE "  configura il mock di un servizio esterno per risponde con la response " xml ". Se nessun xml è passato viene utilizzato quello salvato precedentemente nel contesto con _Given initial XML {service} " xml "_          |
|   mock|   **Given** {mock} wait for {sec} seconds at {action} |    configura il mock di un servizio esterno per aspettare {sec} secondi prima di rispondere                                                                                                                                       |
|   config |   **Step** if {field} is {field_value} set {elem} to {value} in {primitive} |    assegna un valore {value} al campo {elem} se il valore del campo {field} è uguale a {field_value}|
|   soap, verify|   **Then** activateIOPayment response and pspNotifyPayment request are consistent |    controlla se la response di activateIOPayment e la request di  pspNotifyPayment sono consistenti|
|   soap, config|   **Step** save {primitive} response in {new_primitive} |    salva la risposta della primitiva {primitive} in una nuova primitiva {new_primitive}|
|   soap, config|   **Step** saving {primitive} request in {new_primitive} |    salva la request della primitiva {primitive} in una nuova primitiva {new_primitive}|
|   config |   **Step** random iuv in context |    genera un iuv casuale nel context|
|   soap, verify|   **Then** {response} response is equal to {response_1} response |    controlla che la {response} sia uguale a {response_1}|
|   soap, verify|   **Then** activateIOPayment response and pspNotifyPayment request are consistent with paypal |    controlla se la response di activateIOPayment e la request pspNotifyPayment sono consistenti con paypal|
|   config|   **Step** idChannel with USE_NEW_FAULT_CODE=Y |    N.A.|
|   config |   **Step**"random idempotencyKey having {value} as idPSP in {primitive}"|    assegna casualmente il valore di idempotencyKey con {value} idPSP nella primitiva|
|   config |   **Step**"random noticeNumber in {primitive}"|    assegna un noticeNumber casuale nella primitiva {primitive}|
|   query, config|   **Step**"nodo-dei-pagamenti has config parameter {param} set to {value}"|    controlla che il nodo-dei-pagamenti configurato con {param} a {value} sia in status_code =200|
|   config |   **Step**"refresh job {job_name} triggered after 10 seconds"|    aggiorna il job {job_name} dopo 10 secondi dal trigger|
|   config |   **Step**"change date {date} to {add_remove} minutes {minutes:d}"|    aggiunge o rimuove alla data {date}  {minutes:d} minuti in base al valore del campo {add_remove}. Se valorizzato con 'add' aggiunge minuti, diversamente con 'remove' li toglie.|
|   query, config|   **Step**"update through the query {query_name} with date {date} under macro {macro} on db {db_name}"|    N.A.|
|   util|   **Then**"restore initial configurations"|    resetta le configurazioni|
|   query, config|   **Step**"execution query {query_name} to get value on the table {table_name}, with the columns {columns} under macro {macro} with db name {db_name}"|   recupera valore dalla tabella {table_name} tramite query {query_name} nelle colonne {columns}, sotto la macro {macro} nel db {db_name}|
|   query, config|   **Step**"through the query {query_name} retrieve param {param} at position {position:d} and save it under the key {key}"|    salva il risultato {param} alla posizione d {position:d} della query {query_name} sotto la chiave {key} nel context|
|   query, config|   **Step**"through the query {query_name} retrieve param {param} at position {position:d} in the row {row_number:d} and save it under the key {key}"|    salva il risultato {param} alla posizione d {position:d} nella riga d {row_number:d} della query {query_name} sotto la chiave {key} nel context|
|   query, config|   **Step**"through the query {query_name} retrieve xml {xml} at position {position:d} and save it under the key {key}"|    salva l'xml {xml} alla posizione d {position:d} della query {query_name} sotto la chiave {key} nel context|
|   query, config|   **Step**"through the query {query_name} retrieve xml_no_decode {xml} at position {position:d} and save it under the key {key}"|    salva l'xml_no_decode {xml} alla posizione d {position:d} della query {query_name} sotto la chiave {key} nel context|
|   query, verify|   **Step**"with the query {query_name1} check assert beetwen elem {elem1} in position {position1:d} and elem {elem2} with position {position2:d} of the query {query_name2}"|    verifica che il valore del {elem1}, risultato della query {query_name1} alla posizione d {position1:d}, sia uguale al valore {elem2}, risultato della query {query_name2} alla posizione d {position2:d}|
|   config|   **Step**"call the {elem} of {primitive} response as {name}"|    chiama {element} della risposta soap {primitive} come {name}|
|   soap, verify|   **Then**"verify the {elem} of the {primitive} response is equals to {name}"|    verifica che il {element} presente nella risposta della soap {primitive} sia uguale a {name}                                                                                                                                                   |
|   soap, verify|   **Then**"verify the {elem} of the {primitive} response is not equals to {name}"|    verifica che il {element} presente nella risposta della soap {primitive} non sia uguale a {name}                                                                                                                                                   |
|   config|   **Given**"PSP waits {elem} of {primitive} expires"|    configura il PSP in modo da attendere la scadenza del {elem} della primitiva {primitive}                                                                                     |
|   mock, config|   **Step**"{mock:EcPsp} waits {number} minutes for expiration"|    configura il mock di un servizio esterno da attendere {number} minuti prima di scadere                                                                                                                      |
|   config|   **Step**"wait {number} seconds for expiration"|    configurada attendere {number} secondi prima di scadere                                                                                                                      |
|   mock, config|   **Step**"{mock:EcPsp} waits {number} seconds for expiration"|    configura il mock di un servizio esterno da attendere {number} secondi prima di scadere                                                                                                                      |
|   config|   **Step**"idempotencyKey valid for {seconds} seconds"|    NA|
|   query, verify|   **Step**"checks the value {value} of the record at column {column} of the table {table_name} retrived by the query {query_name} on db {db_name} under macro {name_macro}"|    verifica che il valore {value} sia risultato della query {query_name} alla record della colonna {column} della tabella {table_name} nel db {db_name} sotto la macro {name_macro}|
|   query, config|   **Step**"update through the query {query_name} of the table {table_name} the parameter {param} with {value}, with where condition {where_condition} and where value {valore} under macro {macro} on db {db_name}"|    aggiorna il parametro {param} con valore {value} nella tabella {table_name}, tramite la query {query_name} che ha come condizione WHERE {where_condition} e valore {where_value}, sotto la macro {macro} nel db {db_name}|
|   query, config|   **Step**"delete with the query {query_name} from the table {table_name} the parameters where the condition are {where_condition}under macro {macro} on db {db_name}"|    cancella i parametri nella tabella {table_name}, tramite la query {query_name} che ha come condizioni WHERE {where_condition}, sotto la macro {macro} nel db {db_name}|
|   query, config|   **Step**"generic update through the query {query_name} of the table {table_name} the parameter {param}, with where condition {where_condition} under macro {macro} on db {db_name}"|    aggiornamento generico del parametro {param} nella tabella {table_name}, tramite la query {query_name} che ha come condizioni WHERE {where_condition}, sotto la macro {macro} nel db {db_name}|
|   query, verify|   **Step**"check datetime plus number of date {number} of the record at column {column} of the table {table_name} retrived by the query {query_name} on db {db_name} under macro {name_macro}"|    verifica il valore della dataora + variabile {number} sia risultato della query {query_name} alla record della colonna {column} della tabella {table_name} nel db {db_name} sotto la macro {name_macro}|
|   query, verify|   **Step**"checks datetime plus number of date {number} of the record at column {column} in the row {row:d} of the table {table_name} retrived by the query {query_name} on db {db_name} under macro {name_macro}"|    verifica il valore della dataora + variabile {number} sia risultato della query {query_name} alla record della riga {row:d} della tabella {table_name} nel db {db_name} sotto la macro {name_macro}|
|   query, verify|   **Step**"verify datetime plus number of minutes {number} of the record at column {column} of the table {table_name} retrived by the query {query_name} on db {db_name} under macro {name_macro}"|    verifica il valore della dataora + minuti{number} sia risultato della query {query_name} alla record della colonna {column} della tabella {table_name} nel db {db_name} sotto la macro {name_macro}|
|   query, verify|   **Step**"verify {number:d} record for the table {table_name} retrived by the query {query_name} on db {db_name} under macro {name_macro}"|    verifica il numero dei record {number:d} risultato della query {query_name} della tabella {table_name} nel db {db_name} sotto la macro {name_macro}|
|   query, verify|   **Step**"verify if the records for the table {table_name} retrived by the query {query_name} on db {db_name} under macro {name_macro} are not null"|    verifica che i record risultato della query {query_name} della tabella {table_name} nel db {db_name} sotto la macro {name_macro} non siano NULL|
|   verify|   **Step** check token_valid_to is {condition} token_valid_from plus {param} |    verifica il confronto tra token_valid_to e token_valid_from plus variabile tempo {param}|
|   verify|   **Step** check value {value1} is {condition} value {value2} |    verifica il confronto tra il valore {value1} e {value2}|
|   rest|   **Step**"calling primitive {primitive1} {restType1} and {primitive2} {restType2} in parallel"|    chiama la primitiva {primitive1} di tipo REST {restType1} e la primitiva {primitve2} di tipo REST {restType2} contemporaneamente|
|   rest|   **Step**"calling primitive {primitive1} {restType1} and {primitive2} {restType2} with {delay1:d} ms delay"|    chiama la primitiva {primitive1} di tipo REST {restType1}, attende un delay {delay1:d} in ms e poi chiama la primitiva {primitve2} di tipo REST {restType2} |
|   verify|   **Then**"check primitive response {primitive1} and primitive response {primitive2}"|    verifica la risposta della soap {primitive1} e la risposta della soap {primitive2}                                                                                                                                                   |
|   verify|   **Then**"RTP XML check"|    verifica la corretta formattazione del RPT|
|   config|   **Step** retrieve session token from {url} |    recupera il token della sessione dalla {url}|
|   config|   **Step** retrieve session token {number:d} from {url} |    recupera il token della sessione {number:d} dalla {url}|
|   config|   **Step** retrieve url from {url} |    recupera l'url dalla {url}|
|   config|   **Step** replace {old_attribute} content with {new_attribute} content |    sostituisce {old_attribute} con {new_attribute}|
|   config|   **Step** run in parallel "{feature}", "{scenario}" |    esegue in paralello {feature},{scenario}|
|   config|   **Step** export elem {elem} with value {value} in cache |    esporta elemento {element} con valore {value} nel file /../resources/cache.json|
|   config|   **Step** delete cache |    cancella il cache ( file /../resources/cache.json )|



# Placeholder
La sintassi `#nome-variabile#` permette di utilizzare i valori delle varibili globali
_Nota: idempotency_key e notice_number vengono generati ogni volta_

La sintassi `$nomeXml.nomeTag` permette di utilizzare il valore di un tag di un xml precedente
_Nota: nomePrimitiva+Response (es: verifyNoticeNumberResponse) permette di accedere alla response di una chiamata SOAP_
